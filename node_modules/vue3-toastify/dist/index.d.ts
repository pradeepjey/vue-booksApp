import * as vue from 'vue';
import { VNode, DefineComponent, CSSProperties, App, Ref, ComputedRef, Events, Plugin } from 'vue';

/**
 * Used when providing custom icon
 */
interface IconProps {
    theme: ToastTheme;
    type: ToastType;
    path?: string;
}
type BuiltInIconProps = HTMLOrSVGElement & IconProps;
type Content = string | VNode | ((props: ToastContentProps) => VNode) | DefineComponent<{}, {}, any>;
type ToastFunc = {
    (content: Content, options?: ToastOptions): void;
};
type Id = number | string;
type ToastType = 'info' | 'success' | 'error' | 'warning' | 'loading' | 'default';
type ToastPosition = 'top-left' | 'top-right' | 'top-center' | 'bottom-left' | 'bottom-right' | 'bottom-center';
type ToastTransition = 'zoom' | 'flip' | 'bounce' | 'slide';
type ToastTheme = 'auto' | 'light' | 'dark' | 'colored';
interface CloseButtonProps {
    closeToast: (e: MouseEvent) => void;
    type: ToastType;
    ariaLabel?: string;
    theme: ToastTheme;
}
interface ToastContentProps<Data = {}> {
    closeToast?: (e?: MouseEvent) => void;
    toastProps?: ToastOptions;
    data: Data;
}
type IconType = boolean | string | number | VNode | ((props: IconProps) => VNode) | DefineComponent<IconProps, {}, {}>;
type CloseBtnType = boolean | ((props: CloseButtonProps) => VNode) | DefineComponent<IconProps, {}, {}>;
/**
 * options for toast
 */
interface Options {
    /**
     * Support right to left content
     * @default false
     */
    rtl?: boolean;
    /** Used to identify the ToastContainer when working with multiple container. Also used to set the id attribute */
    containerId?: Id;
    /**
     * One of top-right, top-center, top-left, bottom-right, bottom-center, bottom-left
     * @mark {@link ToastPosition}
     * @default 'top-right'
     */
    position?: ToastPosition;
    /**
     * Delay in ms to close the toast. If set to false, the notification needs to be closed manually
     * @default 5000
     */
    autoClose?: number | boolean;
    /**
     * Pass a custom close button.
     * To remove the close button pass `false`
     */
    closeButton?: CloseBtnType;
    /**
     * A reference to a valid react-transition-group/Transition component
     * @default 'bounce'
     */
    transition?: ToastTransition | CSSTransitionProps;
    /**
     * Display or not the progress bar below the toast(remaining time)
     * @default false
     */
    hideProgressBar?: boolean;
    /**
     * Keep the timer running or not on hover
     * @default true
     */
    pauseOnHover?: boolean;
    /**
     * Pause the timer when the window loses focus
     * @default true
     */
    pauseOnFocusLoss?: boolean;
    /**
     * Dismiss toast on click
     * @default true
     */
    closeOnClick?: boolean;
    /**
     * Add optional classes to the toast wrapper
     * @default -
     */
    toastClassName?: string;
    /**
     * Add optional classes to the TransitionGroup container
     * @default ''
     */
    bodyClassName?: string;
    /**
     * Add optional inline style to the container
     * @default {}
     */
    style?: CSSProperties;
    /**
     * Add optional classes to the progress bar
     * @default -
     */
    progressClassName?: string;
    /**
     * Add optional inline style to the progress bar
     * @default {}
     */
    progressStyle?: CSSProperties;
    /**
     * Define the ARIA role for the toasts
     * @default 'alert'
     */
    role?: string;
    /**
     * One of auto, light, dark, colored
     * @description `auto` means automatically detects system theme colors
     * @mark {@link ToastTheme}
     * @default 'auto'
     */
    theme?: ToastTheme;
}
/**
 * options for app.use
 */
interface ToastContainerOptions extends Options {
    /**
     * Display newest toast on top
     * @default false
     */
    newestOnTop?: boolean;
    /**
     * Add optional classes to the container
     * @default -
     */
    containerClassName?: string;
    /**
     * Used to limit the number of toast displayed on screen at the same time
     * @default -
     */
    limit?: number;
}
interface ToastOptions<Data = {}> extends Options {
    /**
     * Set a custom `toastId`
     */
    toastId?: Id;
    /**
     * Used during update
     */
    updateId?: Id;
    /** toast content */
    content?: Content;
    /**
     * any additional data you want to pass toast("content", { data: {key: value} })
     * @default {}
     */
    data?: Data;
    /**
     * One of info, success, warning, error, default, loading
     * @mark {@link ToastType}
     * @default 'default'
     */
    type?: ToastType;
    /**
     * Used to display a custom icon. Set it to `false` to prevent
     * the icons from being displayed
     * @default -
     */
    icon?: IconType;
    /**
     * Let you delay the toast appearance. Pass a value in ms
     * @default -
     */
    delay?: number;
    /**
     * Called when toast is mounted.
     */
    onOpen?: () => void;
    /**
     * Called when toast is unmounted.
     */
    onClose?: () => void;
    /**
     * Called when click inside Toast notification
     * @default -
     */
    onClick?: (event: MouseEvent) => void;
    /**
     * An optional inline style to apply.
     */
    toastStyle?: CSSProperties;
    /**
     * Set the percentage for the controlled progress bar. `Value must be between 0 and 1.`
     */
    progress?: number;
    isLoading?: boolean;
}
type ToastProps = ToastOptions & ToastContainerOptions;
/**
 * ClassName for the elements - can take a function to build a classname or a raw string that is cx'ed to defaults
 */
type ToastClassName = ((context?: {
    type?: ToastType;
    defaultClassName?: string;
    position?: ToastPosition;
    rtl?: boolean;
}) => string) | string;
type Data = Record<string, unknown>;
type ToastItemStatus = 'added' | 'removed' | 'updated';
interface Toast {
    content: Content;
    props: ToastOptions;
}
interface CSSTransitionProps {
    /**
     * Css class to apply when toast enter
     */
    enter: string;
    /**
     * Css class to apply when toast leave
     */
    exit: string;
    /**
     * Append current toast position to the classname.
     * If multiple classes are provided, only the last one will get the position
     * For instance `myclass--top-center`...
     * `Default: false`
     */
    appendPosition?: boolean;
    /**
     * Collapse toast smoothly when exit animation end
     * `Default: true`
     */
    collapse?: boolean;
    /**
     * Collapse transition duration
     * `Default: 300`
     */
    collapseDuration?: number;
}
declare const enum AnimationStep {
    Enter = 0,
    Exit = 1
}
type Nullable<T> = {
    [P in keyof T]: T[P] | null;
};
type ToastContent<T = unknown> = string | VNode | ((props: ToastContentProps<T>) => string | VNode) | DefineComponent<{}, {}, any> | (() => string);
interface UpdateOptions<T = unknown> extends Nullable<ToastOptions<T>> {
    /**
     * Used to update a toast.
     * Pass any valid ReactNode(string, number, component)
     */
    render?: ToastContent<T>;
}

declare const ToastifyContainer: DefineComponent<ToastOptions<{}>, {}, {}, vue.ComputedOptions, vue.MethodOptions, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<ToastOptions<{}>>, {}>;

/** default toast */
declare const toast: {
    (content: Content, options?: ToastOptions): Id;
    /** info toast */
    info(content: Content, options?: ToastOptions): Id;
    /** error toast */
    error(content: Content, options?: ToastOptions): Id;
    /** warning toast */
    warning(content: Content, options?: ToastOptions): Id;
    warn: (content: Content, options?: ToastOptions) => Id;
    /** success toast */
    success(content: Content, options?: ToastOptions): Id;
    /** loading toast */
    loading(content: Content, options?: ToastOptions): Id;
    /** dark toast */
    dark(content: Content, options?: ToastOptions): Id;
    /** remove a toast */
    remove(toastId?: Id): void;
    /** clear all toast */
    clearAll(containerId?: Id): void;
    /**
     * return true if one container is displaying the toast
     */
    isActive(toastId: Id): boolean;
    update(toastId: Id, options?: UpdateOptions): void;
    /**
     * Used for controlled progress bar.
     */
    done(id: Id): void;
    promise: typeof handlePromise;
    POSITION: {
        TOP_LEFT: ToastPosition;
        TOP_RIGHT: ToastPosition;
        TOP_CENTER: ToastPosition;
        BOTTOM_LEFT: ToastPosition;
        BOTTOM_RIGHT: ToastPosition;
        BOTTOM_CENTER: ToastPosition;
    };
    THEME: {
        AUTO: ToastTheme;
        LIGHT: ToastTheme;
        DARK: ToastTheme;
        COLORED: ToastTheme;
    };
    TYPE: {
        INFO: ToastType;
        SUCCESS: ToastType;
        WARNING: ToastType;
        ERROR: ToastType;
        DEFAULT: ToastType;
    };
    TRANSITIONS: {
        FLIP: ToastTransition;
        SLIDE: ToastTransition;
        ZOOM: ToastTransition;
        BOUNCE: ToastTransition;
    };
};
interface ToastPromiseParams<T = unknown> {
    pending?: string | UpdateOptions<void>;
    success?: string | UpdateOptions<T>;
    error?: string | UpdateOptions<any>;
}
declare function handlePromise<T = unknown>(promise: Promise<T> | (() => Promise<T>), { pending, error, success }: ToastPromiseParams<T>, options?: ToastOptions): Promise<T>;

declare const enum Event {
    /** add a toast */
    Add = 0,
    /** remove a toast */
    Remove = 1,
    /** update a toast */
    Update = 2,
    /** clear all toast items */
    ClearAll = 3
}
type NotValidatedToastProps = Partial<ToastOptions>;
type OnAddCallback = (content: Content, options: NotValidatedToastProps) => void;
type OnRemoveCallback = (id: Id) => void;
type OnClearAllQueueCallback = (containerId?: Id) => void;
type OnUpdateCallback = (toast: UpdateOptions) => void;
type Callback = OnAddCallback | OnRemoveCallback | OnClearAllQueueCallback | OnUpdateCallback;
type TimeoutId = ReturnType<typeof setTimeout>;
interface EventManager {
    list: Map<Event, Callback[]>;
    emitQueue: Map<Event, TimeoutId[]>;
    on(event: Event.Add, callback: OnAddCallback): EventManager;
    on(event: Event.Remove, callback: OnRemoveCallback): EventManager;
    on(event: Event.Update, callback: OnUpdateCallback): EventManager;
    on(event: Event.ClearAll, callback: OnClearAllQueueCallback): EventManager;
    off(event: Event, callback?: Callback): EventManager;
    cancelEmit(event: Event): EventManager;
    emit(event: Event.Add, content: Content, options: NotValidatedToastProps): void;
    emit(event: Event.Remove, id: Id): void;
    emit(event: Event.Update, data: UpdateOptions): void;
    emit(event: Event.ClearAll, containerId?: Id): void;
}
declare const eventManager: EventManager;

declare const containerInstances: Record<string, App<Element>>;
declare function cacheRenderInstance(app: App<Element>, id: Id): void;
declare function unmountContainer(containerId: Id): void;
declare function unmountAllContainer(): void;

declare const globalOptions: {
    [key: string]: ToastContainerOptions;
};

interface ToastMap {
    [containerId: Id]: ToastOptions[];
}
declare const toastMap: ToastMap;
declare function getAllToast(): ToastOptions<{}>[];
/**
 * Get the toast by id, given it's in the DOM, otherwise returns null
 */
declare function getToast(toastId: Id): ToastOptions<{}> | undefined;
declare function getContainerId(id: Id): Id | undefined;
declare function removeOne(id?: Id): void;
declare function addOne(_: Content, opts: ToastProps): void;
declare function updateToast(opts?: UpdateOptions<unknown>): void;
declare function clearAll(containerId?: Id): void;
declare function useToastContainer(props?: ToastProps): {
    toastMap: ToastMap;
};

type EventHandlers<E> = {
    [K in keyof E]?: E[K] extends Function ? E[K] : (payload: E[K]) => void;
};
interface OtherProps extends ToastProps {
    toastRef: Ref<HTMLDivElement | undefined>;
    loading: ComputedRef<boolean>;
    /** on propgress end or cancel */
    done?: () => void;
}
declare function useCssTransition(props: CSSTransitionProps & OtherProps): {
    isIn: Ref<boolean>;
    isRunning: Ref<boolean>;
    hideToast: (e?: MouseEvent) => void;
    eventHandlers: ComputedRef<EventHandlers<Events>>;
};

declare const Bounce: CSSTransitionProps;
declare const Slide: CSSTransitionProps;
declare const Zoom: CSSTransitionProps;
declare const Flip: CSSTransitionProps;

declare const Vue3Toastify: Plugin;
declare function updateGlobalOptions(options?: Partial<ToastContainerOptions>): void;

export { AnimationStep, Bounce, BuiltInIconProps, CSSTransitionProps, CloseBtnType, CloseButtonProps, Content, Data, Event, EventManager, Flip, IconProps, IconType, Id, OnUpdateCallback, Options, Slide, Toast, ToastClassName, ToastContainerOptions, ToastContent, ToastContentProps, ToastFunc, ToastItemStatus, ToastMap, ToastOptions, ToastPosition, ToastProps, ToastTheme, ToastTransition, ToastType, ToastifyContainer, UpdateOptions, Zoom, addOne, cacheRenderInstance, clearAll, containerInstances, Vue3Toastify as default, eventManager, getAllToast, getContainerId, getToast, globalOptions, removeOne, toast, toastMap, unmountAllContainer, unmountContainer, updateGlobalOptions, updateToast, useCssTransition, useToastContainer };
