import {
  Fragment,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createElementBlock,
  createVNode,
  defineComponent,
  inject,
  markRaw,
  mergeProps,
  normalizeClass,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toHandlers,
  vShow,
  withCtx,
  withDirectives
} from "./chunk-HEFM7GRK.js";
import "./chunk-DFKQJ226.js";

// node_modules/vue-haystack/dist/vue-haystack.es.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
var createItemStoreInstance = (createItem, extendStore = () => ({})) => {
  const items = ref([]);
  const remove = (itemId) => {
    const index = items.value.findIndex((item) => item.id === itemId);
    if (index === -1) {
      return;
    }
    items.value.splice(index, 1);
  };
  const push = (component, props, listeners, options) => {
    const { item, useReturn } = createItem({
      id: v4(),
      component: markRaw(component),
      props: props || {},
      listeners: listeners || {},
      options: options || null
    });
    items.value.push(item);
    return useReturn;
  };
  const rawStore = {
    items,
    remove,
    push
  };
  const store2 = __spreadValues(__spreadValues({}, rawStore), extendStore(items));
  const useStore = () => {
    return store2;
  };
  const ItemSymbol = Symbol("item");
  const provideItem = (item) => {
    provide(ItemSymbol, item);
    return item;
  };
  const useItem = () => {
    return inject(ItemSymbol);
  };
  return {
    store: store2,
    useStore,
    useItem,
    provideItem
  };
};
var store$1 = createItemStoreInstance((base) => {
  let closeResolve;
  const closePromise = new Promise((resolve) => {
    closeResolve = resolve;
  });
  const item = __spreadProps(__spreadValues({}, base), {
    close: (data) => {
      modalStore.remove(base.id);
      closeResolve(data);
    },
    options: __spreadValues({
      closeOnOverlayClick: true
    }, base.options)
  });
  return {
    item,
    useReturn: {
      onClose: (callback) => {
        closePromise.then(callback);
        return item;
      }
    },
    options: item.options
  };
}, (items) => {
  return {
    activeModal: computed(() => {
      return items.value.slice(-1)[0] || null;
    })
  };
});
var { useStore: useModalStore, useItem: useModal, provideItem: provideModal, store: modalStore } = store$1;
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var _sfc_main$3 = defineComponent({
  name: "ModalProvider",
  components: {},
  props: {
    modal: {
      type: Object,
      required: true
    }
  },
  setup: (props) => {
    provideModal(props.modal);
    return {};
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default", { modal: _ctx.modal })
  ]);
}
var ModalProvider = _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var modalContainer = "_modalContainer_ato2o_1";
var overlay = "_overlay_ato2o_13";
var layer = "_layer_ato2o_21";
var clickable = "_clickable_ato2o_26";
var modal = "_modal_ato2o_1";
var style0$1 = {
  modalContainer,
  overlay,
  layer,
  clickable,
  modal
};
var _sfc_main$2 = defineComponent({
  name: "ModalContainer",
  components: { ModalProvider },
  setup: (_props) => {
    const modalStore2 = useModalStore();
    const activeModal = computed(() => {
      return modalStore2.activeModal.value;
    });
    const overlayClick = (modal2) => {
      var _a;
      if ((_a = modal2.options) == null ? void 0 : _a.closeOnOverlayClick) {
        modal2.close();
      }
    };
    const modals = computed(() => {
      return modalStore2.items.value;
    });
    return { modals, activeModal, overlayClick };
  }
});
var _hoisted_1 = ["onClick"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ModalProvider = resolveComponent("ModalProvider");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.$style.modalContainer)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modals, (modal2) => {
      return openBlock(), createBlock(_component_ModalProvider, {
        key: modal2.id,
        modal: modal2
      }, {
        default: withCtx(() => {
          var _a, _b;
          return [
            withDirectives(createBaseVNode("div", {
              class: normalizeClass([_ctx.$style.overlay, { [_ctx.$style.clickable]: (_a = modal2.options) == null ? void 0 : _a.closeOnOverlayClick }]),
              onClick: ($event) => _ctx.overlayClick(modal2)
            }, [
              renderSlot(_ctx.$slots, "overlay", {}, () => [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.$style.layer)
                }, null, 2)
              ])
            ], 10, _hoisted_1), [
              [vShow, modal2.id === ((_b = _ctx.activeModal) == null ? void 0 : _b.id)]
            ]),
            renderSlot(_ctx.$slots, "default", {
              modal: modal2,
              activeModal: _ctx.activeModal
            }, () => {
              var _a2;
              return [
                withDirectives((openBlock(), createBlock(resolveDynamicComponent(modal2.component), mergeProps({
                  key: modal2.id,
                  class: _ctx.$style.modal
                }, modal2.props, toHandlers(modal2.listeners)), null, 16, ["class"])), [
                  [vShow, modal2.id === ((_a2 = _ctx.activeModal) == null ? void 0 : _a2.id)]
                ])
              ];
            })
          ];
        }),
        _: 2
      }, 1032, ["modal"]);
    }), 128))
  ], 2);
}
var cssModules$1 = {
  "$style": style0$1
};
var ModalContainer = _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__cssModules", cssModules$1]]);
var snackTimer = (callback, duration = 0, updateInterval = 100) => {
  let startTime = new Date().getTime();
  let delay = duration;
  const remainingTime = reactive({ value: duration });
  const progress = reactive({ value: 1 });
  let timeout = null;
  let remainderInterval = null;
  const clear = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    if (remainderInterval) {
      clearInterval(remainderInterval);
      remainderInterval = null;
    }
  };
  const pause = () => {
    clear();
    delay = delay - (new Date().getTime() - startTime);
  };
  const resume = () => {
    if (duration <= 0) {
      return;
    }
    if (!timeout) {
      timeout = setTimeout(callback, delay);
    }
    startTime = new Date().getTime();
    if (!remainderInterval) {
      remainderInterval = setInterval(() => {
        const time = delay - (new Date().getTime() - startTime);
        remainingTime.value = time;
        progress.value = time / duration;
      }, updateInterval);
    }
  };
  resume();
  return {
    clear,
    pause,
    resume,
    remainingTime,
    progress,
    duration
  };
};
var store = createItemStoreInstance((base) => {
  let closeResolve;
  const closePromise = new Promise((resolve) => {
    closeResolve = resolve;
  });
  const options = __spreadValues({
    time: 0
  }, base.options);
  const item = __spreadProps(__spreadValues({}, base), {
    close: (data) => {
      snackbarStore.remove(base.id);
      closeResolve(data);
      item.timer.clear();
    },
    timer: snackTimer(() => {
      item.close();
    }, options.time),
    options
  });
  return {
    item,
    useReturn: {
      onClose: (callback) => {
        closePromise.then(callback);
        return item;
      }
    },
    options: item.options
  };
}, (_items) => {
  return {
    log: () => {
      console.log(_items);
    }
  };
});
var { useStore: useSnackbar, useItem: useSnack, provideItem: provideSnack, store: snackbarStore } = store;
var _sfc_main$1 = defineComponent({
  name: "SnackProvider",
  components: {},
  props: {
    snack: {
      type: Object,
      required: true
    }
  },
  setup: (props) => {
    provideSnack(props.snack);
    return {};
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default", { snack: _ctx.snack })
  ]);
}
var SnackProvider = _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var snackContainer = "_snackContainer_1io5o_1";
var snackProvider = "_snackProvider_1io5o_13";
var snack = "_snack_1io5o_1";
var leaveActive = "_leaveActive_1io5o_20";
var enterFrom = "_enterFrom_1io5o_24";
var leaveTo = "_leaveTo_1io5o_29";
var style0 = {
  snackContainer,
  snackProvider,
  snack,
  leaveActive,
  enterFrom,
  leaveTo
};
var _sfc_main = defineComponent({
  name: "SnackContainer",
  components: { SnackProvider },
  setup: (_props) => {
    const store2 = useSnackbar();
    const snacks = computed(() => {
      return store2.items.value;
    });
    return { snacks };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SnackProvider = resolveComponent("SnackProvider");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.$style.snackContainer)
  }, [
    createVNode(TransitionGroup, {
      "leave-active-class": _ctx.$style.leaveActive,
      "enter-from-class": _ctx.$style.enterFrom,
      "leave-to-class": _ctx.$style.leaveTo,
      appear: ""
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.snacks, (snack2) => {
          return openBlock(), createBlock(_component_SnackProvider, {
            key: snack2.id,
            class: normalizeClass(_ctx.$style.snackProvider),
            snack: snack2
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", { snack: snack2 }, () => [
                (openBlock(), createBlock(resolveDynamicComponent(snack2.component), mergeProps({
                  key: snack2.id,
                  class: _ctx.$style.snack
                }, snack2.props, toHandlers(snack2.listeners)), null, 16, ["class"]))
              ])
            ]),
            _: 2
          }, 1032, ["class", "snack"]);
        }), 128))
      ]),
      _: 3
    }, 8, ["leave-active-class", "enter-from-class", "leave-to-class"])
  ], 2);
}
var cssModules = {
  "$style": style0
};
var SnackContainer = _export_sfc(_sfc_main, [["render", _sfc_render], ["__cssModules", cssModules]]);
export {
  ModalContainer,
  ModalProvider,
  SnackContainer,
  SnackProvider,
  createItemStoreInstance,
  modalStore,
  provideModal,
  provideSnack,
  snackTimer,
  snackbarStore,
  useModal,
  useModalStore,
  useSnack,
  useSnackbar
};
//# sourceMappingURL=vue-haystack.js.map
